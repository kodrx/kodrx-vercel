<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KodRx ¬∑ Backfill medicoUid</title>
  <link rel="stylesheet" href="/estilos/global.css" />
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:#f6f7fb; padding:20px; }
    .wrap { max-width: 980px; margin: 0 auto; }
    h1 { margin: 0 0 12px; color:#123f91; }
    .card { background:#fff; border:1px solid #e5e7eb; border-radius:14px; padding:16px 18px; box-shadow:0 2px 12px rgba(10,22,50,.04); }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    .btn { padding:.6rem 1rem; border:0; border-radius:12px; background:#0b5bd3; color:#fff; font-weight:600; cursor:pointer; }
    .btn:disabled { opacity:.6; cursor:not-allowed; }
    .btn.alt { background:#334155; }
    .muted { color:#64748b; font-size:13px; }
    .field { padding:.5rem .7rem; border:1px solid #cbd5e1; border-radius:10px; min-width: 220px; }
    .badge { display:inline-block; padding:2px 8px; border-radius:999px; background:#eef2ff; color:#334155; font-size:12px; }
    pre#log { background:#0b1220; color:#e2e8f0; padding:12px; border-radius:10px; max-height:45vh; overflow:auto; font-size:12px; }
    .ok { color:#16a34a; } .warn { color:#b45309; } .err { color:#ef4444; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:14px; }
    @media (max-width:880px){ .grid { grid-template-columns: 1fr; } }
    select.field { min-width:260px; }
    code { background:#f1f5f9; padding:2px 6px; border-radius:6px; }
    .hint { font-size:12px; color:#475569; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Backfill de <code>medicoUid</code> en recetas</h1>

    <div class="card" style="margin-bottom:14px;">
      <div id="userBox" class="muted">Verificando sesi√≥n‚Ä¶</div>
      <div class="row" style="margin-top:10px;">
        <label><input type="checkbox" id="onlyMissing" checked /> Solo si <code>medicoUid</code> falta</label>
        <label><input type="checkbox" id="dryRun" /> Dry-run (no escribir)</label>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <h3 style="margin:0 0 8px;">Estrategia A ‚Äî Por correo</h3>
        <div class="muted">Buscar recetas con <code>medicoEmail == user.email</code> y asignar <code>medicoUid = user.uid</code>.</div>
        <div class="row" style="margin-top:10px;">
          <button class="btn alt" id="scanEmail">üìä Scan por correo</button>
          <span id="scanEmailCount" class="badge">‚Äî</span>
        </div>
        <div class="row" style="margin-top:10px;">
          <button class="btn" id="runEmail" disabled>‚ñ∂Ô∏è Backfill por correo</button>
        </div>
      </div>

      <div class="card">
        <h3 style="margin:0 0 8px;">Estrategia B ‚Äî Por uid</h3>
        <div class="muted">Buscar recetas con <code>medicoId/uidMedico == user.uid</code> y asignar <code>medicoUid = user.uid</code>.</div>
        <div class="row" style="margin-top:10px;">
          <button class="btn alt" id="scanUid">üìä Scan por uid</button>
          <span id="scanUidCount" class="badge">‚Äî</span>
        </div>
        <div class="row" style="margin-top:10px;">
          <button class="btn" id="runUid" disabled>‚ñ∂Ô∏è Backfill por uid</button>
        </div>
      </div>
    </div>

    <div class="card" style="margin-top:14px;">
      <h3 style="margin:0 0 8px;">üîé Detector de campos & Campo personalizado</h3>
      <div class="muted">Explora recetas para encontrar rutas de campos (incluye anidados) que coincidan con tu <code>uid</code> o <code>email</code>. Luego ejecuta scan/backfill con esa ruta.</div>

      <div class="row" style="margin-top:10px;">
        <button class="btn alt" id="detectFields">üîç Detectar rutas con coincidencias</button>
        <select id="candidateSelect" class="field">
          <option value="">‚Äî sin sugerencias a√∫n ‚Äî</option>
        </select>
        <span id="detectedInfo" class="badge">‚Äî</span>
      </div>

      <div class="row" style="margin-top:10px;">
        <input id="customField" class="field" placeholder="p. ej. correo ¬∑ medico.uid ¬∑ createdBy.uid" />
        <label><input type="radio" name="matchType" value="uid" checked /> Comparar con UID</label>
        <label><input type="radio" name="matchType" value="email" /> Comparar con email</label>
      </div>

      <!-- overrides manuales -->
      <div class="row" style="margin-top:10px;">
        <input id="overrideValue" class="field" placeholder="Valor a comparar (email o uid) ‚Äî opcional" />
        <input id="overrideTargetUid" class="field" placeholder="medicoUid a escribir (uid del m√©dico) ‚Äî opcional" />
      </div>

      <div class="row" style="margin-top:10px;">
        <button class="btn alt" id="scanCustom">üìä Scan personalizado</button>
        <span id="scanCustomCount" class="badge">‚Äî</span>
        <button class="btn" id="runCustom" disabled>‚ñ∂Ô∏è Backfill personalizado</button>
      </div>

      <div id="detectorOut" class="muted" style="margin-top:8px;"></div>
    </div>

    <!-- NUEVO: MODO FLEX -->
    <div class="card" style="margin-top:14px;">
      <h3 style="margin:0 0 8px;">üß≠ Modo FLEX ‚Äî sin conocer el campo</h3>
      <div class="muted">Escanea toda la colecci√≥n y encuentra docs donde <em>cualquier string</em> del documento coincida con tu valor (exacto o por subcadena), con opci√≥n de filtrar por patr√≥n de clave.</div>

      <div class="row" style="margin-top:10px;">
        <input id="flexValue" class="field" placeholder="Valor a buscar (email o uid del m√©dico)" />
        <input id="flexTargetUid" class="field" placeholder="medicoUid a escribir (uid del m√©dico)" />
      </div>

      <div class="row">
        <select id="flexMode" class="field">
          <option value="exact">== exacto (sensible a may√∫sculas)</option>
          <option value="iexact">== exacto (ignorar may√∫sculas/espacios)</option>
          <option value="contains">contiene (sensible a may√∫sculas)</option>
          <option value="icontains" selected>contiene (ignorar may√∫sculas/espacios)</option>
        </select>
        <input id="flexKeyRegex" class="field" placeholder="Filtrar por patr√≥n de clave (regex). Ej: medic|correo|email|doctor|autor|createdBy|uid" />
      </div>
      <div class="hint">Consejo: si sabes el correo del m√©dico (p.ej. <code>doctor@ejemplo.com</code>), √∫salo en <b>Valor a buscar</b> y su <b>UID</b> en <b>medicoUid a escribir</b>.</div>

      <div class="row" style="margin-top:10px;">
        <button class="btn alt" id="scanFlex">üìä Scan FLEX</button>
        <span id="scanFlexCount" class="badge">‚Äî</span>
        <button class="btn" id="runFlex" disabled>‚ñ∂Ô∏è Backfill FLEX</button>
      </div>
    </div>

    <div class="card" style="margin-top:14px;">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <div><strong>Progreso & Logs</strong></div>
        <div class="muted">Consulta paginada, lotes de hasta 500 actualizaciones.</div>
      </div>
      <pre id="log"></pre>
    </div>
  </div>

  <!-- M√ìDULO -->
  <script type="module">
    console.log('[backfill] m√≥dulo cargado');
    import { auth, db } from "/firebase-init.js";
    import {
      collection, query, where, orderBy, limit, startAfter, getDocs,
      writeBatch, doc, documentId
    } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-firestore.js";
    import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-auth.js";

    const PAGE = 250;       // lectura por p√°gina
    const BATCH_MAX = 500;  // escrituras por commit
    const DETECT_MAX = 200; // docs para detector

    const $ = (s)=>document.querySelector(s);
    const logEl = $('#log');
    const userBox = $('#userBox');

    const log = (msg, cls='')=>{
      const line = (cls?`<span class="${cls}">`:'') + msg + (cls?'</span>':'');
      logEl.insertAdjacentHTML('beforeend', line + '\n');
      logEl.scrollTop = logEl.scrollHeight;
      console.log('[backfill]', msg);
    };
    const setBusy = (el, busy=true)=>{ if(el){ el.disabled=!!busy; el.__busy=!!busy; } };

    // ---------- helpers comunes ----------
    function* walk(obj, base='') {
      if (obj === null || obj === undefined) return;
      const isTS = obj && typeof obj==='object' && 'seconds' in obj && typeof obj.seconds==='number';
      if (isTS) return;
      if (Array.isArray(obj)) {
        for (let i=0;i<obj.length;i++) yield* walk(obj[i], `${base}[${i}]`);
        return;
      }
      if (typeof obj === 'object') {
        for (const [k,v] of Object.entries(obj)) {
          const path = base ? `${base}.${k}` : k;
          if (v && typeof v === 'object') yield* walk(v, path);
          else yield [path, v];
        }
        return;
      }
      yield [base, obj];
    }
    const norm = s => String(s || '').toLowerCase().trim();

    // ---------- escaneo por where(field==value) ----------
    const scan = async ({ field, value })=>{
      let last = null, total = 0;
      for (;;) {
        let q = query(
          collection(db, 'recetas'),
          where(field, '==', value),
          orderBy(documentId()),
          limit(PAGE)
        );
        if (last) q = query(
          collection(db, 'recetas'),
          where(field, '==', value),
          orderBy(documentId()),
          startAfter(last),
          limit(PAGE)
        );
        const snap = await getDocs(q);
        total += snap.size;
        if (snap.size < PAGE) break;
        last = snap.docs[snap.docs.length-1];
      }
      return total;
    };

    // ---------- backfill por where(field==value) ----------
    const backfill = async ({ field, value, targetUid, onlyMissing=true, dryRun=false })=>{
      log(`Comenzando backfill por ${field} = ${value} (onlyMissing=${onlyMissing}, dryRun=${dryRun})`, 'ok');
      let last = null, totalRead = 0, totalUpd = 0, batch = writeBatch(db), batchCount = 0;
      const flush = async ()=>{
        if (batchCount === 0) return;
        if (dryRun) log(`DRY-RUN: omito commit de ${batchCount} docs`, 'warn');
        else { await batch.commit(); log(`Commit de ${batchCount} docs ‚úÖ`, 'ok'); }
        batch = writeBatch(db); batchCount = 0;
      };
      try {
        for (;;) {
          let q = query(
            collection(db, 'recetas'),
            where(field, '==', value),
            orderBy(documentId()),
            limit(PAGE)
          );
          if (last) q = query(
            collection(db, 'recetas'),
            where(field, '==', value),
            orderBy(documentId()),
            startAfter(last),
            limit(PAGE)
          );

          const snap = await getDocs(q);
          if (snap.empty) break;
          totalRead += snap.size;

          for (const d of snap.docs) {
            const data = d.data() || {};
            const current = data.medicoUid;
            const needs =
              (onlyMissing && (!current || typeof current !== 'string' || !current.trim())) ||
              (!onlyMissing && current !== targetUid);
            if (needs) {
              if (!dryRun) { batch.set(doc(db, 'recetas', d.id), { medicoUid: targetUid }, { merge: true }); }
              batchCount++; totalUpd++;
              if (batchCount >= BATCH_MAX) await flush();
            }
          }

          last = snap.docs[snap.docs.length-1];
          log(`P√°gina procesada: le√≠dos ${totalRead}, marcados ${totalUpd}`, '');
          if (snap.size < PAGE) break;
        }
        await flush();
        log(`Backfill terminado. Le√≠dos: ${totalRead}, actualizados: ${totalUpd}`, 'ok');
      } catch (e) {
        console.error(e);
        log(`ERROR: ${e.code || ''} ${e.message || e}`, 'err');
        if (e.code === 'permission-denied') log('Las reglas bloquearon la escritura. Ejecuta como admin (Admin SDK) o ajusta reglas temporalmente.', 'err');
        throw e;
      }
      return { totalRead, totalUpd };
    };

    // ---------- DETECTOR (sugerencias de paths) ----------
    const detectCandidates = async (user, limitDocs=DETECT_MAX)=>{
      const res = { uidMatches: new Map(), emailMatches: new Map(), sampled:0 };
      let last=null, scanned=0;
      while (scanned < limitDocs) {
        let q = query(collection(db,'recetas'), orderBy(documentId()), limit(PAGE));
        if (last) q = query(collection(db,'recetas'), orderBy(documentId()), startAfter(last), limit(PAGE));
        const snap = await getDocs(q);
        if (snap.empty) break;

        for (const d of snap.docs) {
          const data = d.data();
          for (const [path,val] of walk(data)) {
            if (typeof val !== 'string') continue;
            if (val === user.uid)   res.uidMatches.set(path, (res.uidMatches.get(path)||0)+1);
            if (user.email && val === user.email) res.emailMatches.set(path, (res.emailMatches.get(path)||0)+1);
          }
          scanned++;
          if (scanned >= limitDocs) break;
        }
        last = snap.docs[snap.docs.length-1];
        if (snap.size < PAGE) break;
      }
      res.sampled = scanned;
      return res;
    };

    // ---------- MODO FLEX (sin campo) ----------
    const matchers = {
      exact: (a,b)=> a === b,
      iexact: (a,b)=> norm(a) === norm(b),
      contains: (a,b)=> String(a).includes(String(b)),
      icontains: (a,b)=> norm(a).includes(norm(b)),
    };

    const scanFlex = async ({ value, mode='icontains', keyRegex=null })=>{
      if (!value) return 0;
      const match = matchers[mode] || matchers.icontains;
      const re = keyRegex ? new RegExp(keyRegex, 'i') : null;

      let last=null, total=0, scanned=0;
      for (;;) {
        let q = query(collection(db,'recetas'), orderBy(documentId()), limit(PAGE));
        if (last) q = query(collection(db,'recetas'), orderBy(documentId()), startAfter(last), limit(PAGE));
        const snap = await getDocs(q);
        if (snap.empty) break;

        for (const d of snap.docs) {
          const data = d.data();
          let hit = false;
          for (const [path,val] of walk(data)) {
            if (typeof val !== 'string') continue;
            if (re && !re.test(path)) continue;
            if (match(val, value)) { hit = true; break; }
          }
          if (hit) total++;
        }

        scanned += snap.size;
        last = snap.docs[snap.docs.length-1];
        if (snap.size < PAGE) break;
      }
      return total;
    };

    const backfillFlex = async ({ value, targetUid, mode='icontains', keyRegex=null, onlyMissing=true, dryRun=false })=>{
      const match = matchers[mode] || matchers.icontains;
      const re = keyRegex ? new RegExp(keyRegex, 'i') : null;

      log(`Comenzando FLEX (value=${value}, targetUid=${targetUid}, mode=${mode}, keyRegex=${keyRegex||'‚Äî'}, onlyMissing=${onlyMissing}, dryRun=${dryRun})`, 'ok');

      let last = null, totalRead = 0, totalUpd = 0, batch = writeBatch(db), batchCount = 0;

      const flush = async ()=>{
        if (batchCount === 0) return;
        if (dryRun) log(`DRY-RUN: omito commit de ${batchCount} docs`, 'warn');
        else { await batch.commit(); log(`Commit de ${batchCount} docs ‚úÖ`, 'ok'); }
        batch = writeBatch(db); batchCount = 0;
      };

      try{
        for (;;) {
          let q = query(collection(db,'recetas'), orderBy(documentId()), limit(PAGE));
          if (last) q = query(collection(db,'recetas'), orderBy(documentId()), startAfter(last), limit(PAGE));
          const snap = await getDocs(q);
          if (snap.empty) break;

          for (const d of snap.docs) {
            const data = d.data();
            let hit = false;
            for (const [path,val] of walk(data)) {
              if (typeof val !== 'string') continue;
              if (re && !re.test(path)) continue;
              if (match(val, value)) { hit = true; break; }
            }
            if (!hit) continue;

            totalRead++;
            const current = data.medicoUid;
            const needs =
              (onlyMissing && (!current || typeof current !== 'string' || !current.trim())) ||
              (!onlyMissing && current !== targetUid);

            if (needs) {
              if (!dryRun) batch.set(doc(db,'recetas', d.id), { medicoUid: targetUid }, { merge:true });
              batchCount++; totalUpd++;
              if (batchCount >= BATCH_MAX) await flush();
            }
          }

          last = snap.docs[snap.docs.length-1];
          if (snap.size < PAGE) break;
        }

        await flush();
        log(`FLEX terminado. Coincidencias: ${totalRead}, actualizados: ${totalUpd}`, 'ok');
      } catch(e){
        console.error(e);
        log(`FLEX ERROR: ${e.code||''} ${e.message||e}`, 'err');
        if (e.code === 'permission-denied') log('Reglas bloquearon la escritura. Ejecuta como admin o ajusta reglas temporalmente.', 'err');
        throw e;
      }
      return { totalRead, totalUpd };
    };

    // ---------- UI refs ----------
    let currentUser = null;

    const scanEmailBtn = $('#scanEmail'), scanEmailCount = $('#scanEmailCount'), runEmailBtn = $('#runEmail');
    const scanUidBtn = $('#scanUid'), scanUidCount = $('#scanUidCount'), runUidBtn = $('#runUid');
    const onlyMissingEl = $('#onlyMissing'), dryRunEl = $('#dryRun');

    const detectBtn = $('#detectFields'), candidateSelect = $('#candidateSelect'), detectedInfo = $('#detectedInfo');
    const customField = $('#customField'), scanCustomBtn = $('#scanCustom'), scanCustomCount = $('#scanCustomCount'), runCustomBtn = $('#runCustom');
    const overrideValueEl = $('#overrideValue'), overrideTargetUidEl = $('#overrideTargetUid');
    const detectorOut = $('#detectorOut');

    // FLEX refs
    const flexValueEl = $('#flexValue'), flexTargetUidEl = $('#flexTargetUid');
    const flexModeEl = $('#flexMode'), flexKeyRegexEl = $('#flexKeyRegex');
    const scanFlexBtn = $('#scanFlex'), scanFlexCount = $('#scanFlexCount'), runFlexBtn = $('#runFlex');

    onAuthStateChanged(auth, async (user)=>{
      if (!user) {
        userBox.innerHTML = 'Sin sesi√≥n. <a href="/acceso?role=admin">Inicia sesi√≥n</a>';
        log('No hay sesi√≥n. Inicia sesi√≥n para continuar.', 'err');
        return;
      }
      currentUser = user;
      userBox.innerHTML = `Sesi√≥n: <strong>${user.email || '(sin correo)'}</strong> <span class="badge">uid: ${user.uid}</span>`;
      log(`Autenticado como ${user.email} (${user.uid})`, 'ok');
    });

    // ----- Acciones por correo/uid (como ten√≠as) -----
    scanEmailBtn?.addEventListener('click', async ()=>{
      if (!currentUser?.email) { log('Tu usuario no tiene email. No se puede usar estrategia por correo.', 'err'); return; }
      setBusy(scanEmailBtn, true); scanEmailCount.textContent = '‚Ä¶';
      try{
        const c = await scan({ field: 'medicoEmail', value: currentUser.email });
        scanEmailCount.textContent = String(c);
        runEmailBtn.disabled = c === 0;
        log(`Scan por correo ‚Üí candidatos: ${c}`, c ? 'ok' : 'warn');
      } finally { setBusy(scanEmailBtn, false); }
    });

    runEmailBtn?.addEventListener('click', async ()=>{
      if (!currentUser?.email) return;
      setBusy(runEmailBtn, true);
      try {
        await backfill({
          field: 'medicoEmail',
          value: currentUser.email,
          targetUid: currentUser.uid,
          onlyMissing: !!onlyMissingEl.checked,
          dryRun: !!dryRunEl.checked
        });
      } finally { setBusy(runEmailBtn, false); }
    });

    scanUidBtn?.addEventListener('click', async ()=>{
      if (!currentUser?.uid) return;
      setBusy(scanUidBtn, true); scanUidCount.textContent = '‚Ä¶';
      try{
        const c1 = await scan({ field: 'medicoId', value: currentUser.uid }).catch(()=>0);
        const c2 = await scan({ field: 'uidMedico', value: currentUser.uid }).catch(()=>0);
        const total = c1 + c2;
        scanUidCount.textContent = String(total);
        runUidBtn.disabled = total === 0;
        log(`Scan por uid ‚Üí medicoId:${c1} + uidMedico:${c2} = ${total}`, total ? 'ok' : 'warn');
      } finally { setBusy(scanUidBtn, false); }
    });

    runUidBtn?.addEventListener('click', async ()=>{
      if (!currentUser?.uid) return;
      setBusy(runUidBtn, true);
      try {
        await backfill({ field: 'medicoId',  value: currentUser.uid, targetUid: currentUser.uid, onlyMissing: !!onlyMissingEl.checked, dryRun: !!dryRunEl.checked }).catch(e => log(`medicoId: ${e.message||e}`, 'err'));
        await backfill({ field: 'uidMedico', value: currentUser.uid, targetUid: currentUser.uid, onlyMissing: !!onlyMissingEl.checked, dryRun: !!dryRunEl.checked }).catch(e => log(`uidMedico: ${e.message||e}`, 'err'));
      } finally { setBusy(runUidBtn, false); }
    });

    // ----- Detector / personalizado -----
    detectBtn?.addEventListener('click', async ()=>{
      if (!currentUser) return;
      setBusy(detectBtn, true);
      detectorOut.textContent = 'Escaneando recetas para sugerencias‚Ä¶';
      try {
        const res = await detectCandidates(currentUser, DETECT_MAX);
        const topUID = [...res.uidMatches.entries()].sort((a,b)=>b[1]-a[1]).slice(0,10);
        const topEmail = [...res.emailMatches.entries()].sort((a,b)=>b[1]-a[1]).slice(0,10);

        candidateSelect.innerHTML = '<option value="">‚Äî elige una sugerencia ‚Äî</option>';
        for (const [p,c] of topUID) {
          const opt = document.createElement('option');
          opt.value = JSON.stringify({ path:p, type:'uid' });
          opt.textContent = `${p}  (UID √ó${c})`;
          candidateSelect.appendChild(opt);
        }
        for (const [p,c] of topEmail) {
          const opt = document.createElement('option');
          opt.value = JSON.stringify({ path:p, type:'email' });
          opt.textContent = `${p}  (EMAIL √ó${c})`;
          candidateSelect.appendChild(opt);
        }

        detectedInfo.textContent = `muestra:${res.sampled}  uidHits:${topUID.reduce((s,[_p,c])=>s+c,0)}  emailHits:${topEmail.reduce((s,[_p,c])=>s+c,0)}`;
        const fmtList = (lst, label) => lst.length ? `<div><strong>${label}</strong><ul>` + lst.map(([p,c])=>`<li><code>${p}</code> <span class="badge">√ó${c}</span></li>`).join('') + '</ul></div>' : '';
        detectorOut.innerHTML = fmtList(topUID,'Paths por UID') + fmtList(topEmail,'Paths por EMAIL');
        log(`Detector: analizados ${res.sampled} docs`, 'ok');
      } catch(e) {
        console.error(e);
        detectorOut.textContent = 'Error en detector. Revisa consola.';
        log(`Detector ERROR: ${e.message||e}`, 'err');
      } finally {
        setBusy(detectBtn, false);
      }
    });

    candidateSelect?.addEventListener('change', ()=>{
      const val = candidateSelect.value ? JSON.parse(candidateSelect.value) : null;
      if (!val) return;
      customField.value = val.path;
      const radio = document.querySelector(`input[name="matchType"][value="${val.type}"]`);
      if (radio) radio.checked = true;
    });

    scanCustomBtn?.addEventListener('click', async ()=>{
      if (!currentUser) return;
      const field = (customField.value || '').trim();
      if (!field){ alert('Ingresa una ruta de campo (p. ej. correo / medico.uid)'); return; }
      const mt = (document.querySelector('input[name="matchType"]:checked')?.value)||'uid';
      const auto = (mt==='email') ? (currentUser.email||'') : currentUser.uid;
      const value = (overrideValueEl.value || '').trim() || auto;
      if (!value){ alert('No tengo valor para comparar (email/uid).'); return; }

      setBusy(scanCustomBtn, true); scanCustomCount.textContent = '‚Ä¶';
      try{
        const c = await scan({ field, value });
        scanCustomCount.textContent = String(c);
        runCustomBtn.disabled = c === 0;
        log(`Scan personalizado por ${field} == ${value} ‚Üí ${c}`, c ? 'ok' : 'warn');
      } finally { setBusy(scanCustomBtn, false); }
    });

    runCustomBtn?.addEventListener('click', async ()=>{
      if (!currentUser) return;
      const field = (customField.value || '').trim();
      if (!field){ alert('Ingresa una ruta de campo (p. ej. correo / medico.uid)'); return; }
      const mt = (document.querySelector('input[name="matchType"]:checked')?.value)||'uid';
      const auto = (mt==='email') ? (currentUser.email||'') : currentUser.uid;
      const value = (overrideValueEl.value || '').trim() || auto;
      const targetUid = (overrideTargetUidEl.value || '').trim() || currentUser.uid;
      if (!value || !targetUid){ alert('Falta valor a comparar o medicoUid de destino.'); return; }

      setBusy(runCustomBtn, true);
      try{
        await backfill({
          field,
          value,
          targetUid,
          onlyMissing: !!onlyMissingEl.checked,
          dryRun: !!dryRunEl.checked
        });
      } finally { setBusy(runCustomBtn, false); }
    });

    // ----- FLEX -----
    scanFlexBtn?.addEventListener('click', async ()=>{
      const value = (flexValueEl.value || '').trim();
      if (!value) { alert('Ingresa el valor a buscar (email o uid).'); return; }
      setBusy(scanFlexBtn, true); scanFlexCount.textContent = '‚Ä¶';
      try{
        const c = await scanFlex({
          value,
          mode: flexModeEl.value,
          keyRegex: (flexKeyRegexEl.value || '').trim() || null
        });
        scanFlexCount.textContent = String(c);
        runFlexBtn.disabled = c === 0;
        log(`FLEX scan ‚Üí coincidencias: ${c}`, c ? 'ok' : 'warn');
      } finally { setBusy(scanFlexBtn, false); }
    });

    runFlexBtn?.addEventListener('click', async ()=>{
      const value = (flexValueEl.value || '').trim();
      const targetUid = (flexTargetUidEl.value || '').trim();
      if (!value || !targetUid) { alert('Ingresa valor a buscar y medicoUid a escribir.'); return; }
      setBusy(runFlexBtn, true);
      try{
        await backfillFlex({
          value,
          targetUid,
          mode: flexModeEl.value,
          keyRegex: (flexKeyRegexEl.value || '').trim() || null,
          onlyMissing: !!onlyMissingEl.checked,
          dryRun: !!dryRunEl.checked
        });
      } finally { setBusy(runFlexBtn, false); }
    });

    // Captura global de errores
    window.addEventListener('error', e => log(`JS ERROR: ${e.message}`, 'err'));
    window.addEventListener('unhandledrejection', e => log(`PROMISE REJECTION: ${e.reason?.message || e.reason}`, 'err'));
  </script>
</body>
</html>


